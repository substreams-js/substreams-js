// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file sf/substreams/v1/substreams.proto (package sf.substreams.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Any, Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { Modules } from "./modules_pb.js";
import { Clock } from "./clock_pb.js";

/**
 * @generated from enum sf.substreams.v1.ForkStep
 */
export enum ForkStep {
  /**
   * @generated from enum value: STEP_UNKNOWN = 0;
   */
  STEP_UNKNOWN = 0,

  /**
   * Block is new head block of the chain, that is linear with the previous block
   *
   * @generated from enum value: STEP_NEW = 1;
   */
  STEP_NEW = 1,

  /**
   * Block is now forked and should be undone, it's not the head block of the chain anymore
   *
   * @generated from enum value: STEP_UNDO = 2;
   */
  STEP_UNDO = 2,

  /**
   * Block is now irreversible and can be committed to (finality is chain specific, see chain documentation for more details)
   *
   * @generated from enum value: STEP_IRREVERSIBLE = 4;
   */
  STEP_IRREVERSIBLE = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(ForkStep)
proto3.util.setEnumType(ForkStep, "sf.substreams.v1.ForkStep", [
  { no: 0, name: "STEP_UNKNOWN" },
  { no: 1, name: "STEP_NEW" },
  { no: 2, name: "STEP_UNDO" },
  { no: 4, name: "STEP_IRREVERSIBLE" },
]);

/**
 * @generated from message sf.substreams.v1.Request
 */
export class Request extends Message<Request> {
  /**
   * @generated from field: int64 start_block_num = 1;
   */
  startBlockNum = protoInt64.zero;

  /**
   * @generated from field: string start_cursor = 2;
   */
  startCursor = "";

  /**
   * @generated from field: uint64 stop_block_num = 3;
   */
  stopBlockNum = protoInt64.zero;

  /**
   * @generated from field: repeated sf.substreams.v1.ForkStep fork_steps = 4;
   */
  forkSteps: ForkStep[] = [];

  /**
   * @generated from field: string irreversibility_condition = 5;
   */
  irreversibilityCondition = "";

  /**
   * Substreams has two mode when executing your module(s) either development mode or production
   * mode. Development and production modes impact the execution of Substreams, important aspects
   * of execution include:
   * * The time required to reach the first byte.
   * * The speed that large ranges get executed.
   * * The module logs and outputs sent back to the client.
   *
   * By default, the engine runs in developer mode, with richer and deeper output. Differences
   * between production and development modes include:
   * * Forward parallel execution is enabled in production mode and disabled in development mode
   * * The time required to reach the first byte in development mode is faster than in production mode.
   *
   * Specific attributes of development mode include:
   * * The client will receive all of the executed module's logs.
   * * It's possible to request specific store snapshots in the execution tree (via `debug_initial_store_snapshot_for_modules`).
   * * Multiple module's output is possible.
   *
   * With production mode`, however, you trade off functionality for high speed enabling forward
   * parallel execution of module ahead of time.
   *
   * @generated from field: bool production_mode = 9;
   */
  productionMode = false;

  /**
   * @generated from field: sf.substreams.v1.Modules modules = 6;
   */
  modules?: Modules;

  /**
   * @generated from field: repeated string output_modules = 7;
   */
  outputModules: string[] = [];

  /**
   * Available only in developer mode
   *
   * @generated from field: repeated string debug_initial_store_snapshot_for_modules = 8;
   */
  debugInitialStoreSnapshotForModules: string[] = [];

  /**
   * @generated from field: string output_module = 10;
   */
  outputModule = "";

  constructor(data?: PartialMessage<Request>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.substreams.v1.Request";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_block_num", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "start_cursor", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "stop_block_num", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "fork_steps", kind: "enum", T: proto3.getEnumType(ForkStep), repeated: true },
    { no: 5, name: "irreversibility_condition", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "production_mode", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "modules", kind: "message", T: Modules },
    { no: 7, name: "output_modules", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "debug_initial_store_snapshot_for_modules", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 10, name: "output_module", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Request {
    return new Request().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Request {
    return new Request().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Request {
    return new Request().fromJsonString(jsonString, options);
  }

  static equals(a: Request | PlainMessage<Request> | undefined, b: Request | PlainMessage<Request> | undefined): boolean {
    return proto3.util.equals(Request, a, b);
  }
}

/**
 * @generated from message sf.substreams.v1.Response
 */
export class Response extends Message<Response> {
  /**
   * @generated from oneof sf.substreams.v1.Response.message
   */
  message: {
    /**
     * Always sent first
     *
     * @generated from field: sf.substreams.v1.SessionInit session = 5;
     */
    value: SessionInit;
    case: "session";
  } | {
    /**
     * Progress of data preparation, before sending in the stream of `data` events.
     *
     * @generated from field: sf.substreams.v1.ModulesProgress progress = 1;
     */
    value: ModulesProgress;
    case: "progress";
  } | {
    /**
     * Available only in developer mode, and only if `debug_initial_store_snapshot_for_modules` is set.
     *
     * @generated from field: sf.substreams.v1.InitialSnapshotData debug_snapshot_data = 2;
     */
    value: InitialSnapshotData;
    case: "debugSnapshotData";
  } | {
    /**
     * Available only in developer mode, and only if `debug_initial_store_snapshot_for_modules` is set.
     *
     * @generated from field: sf.substreams.v1.InitialSnapshotComplete debug_snapshot_complete = 3;
     */
    value: InitialSnapshotComplete;
    case: "debugSnapshotComplete";
  } | {
    /**
     * @generated from field: sf.substreams.v1.BlockScopedData data = 4;
     */
    value: BlockScopedData;
    case: "data";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Response>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.substreams.v1.Response";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 5, name: "session", kind: "message", T: SessionInit, oneof: "message" },
    { no: 1, name: "progress", kind: "message", T: ModulesProgress, oneof: "message" },
    { no: 2, name: "debug_snapshot_data", kind: "message", T: InitialSnapshotData, oneof: "message" },
    { no: 3, name: "debug_snapshot_complete", kind: "message", T: InitialSnapshotComplete, oneof: "message" },
    { no: 4, name: "data", kind: "message", T: BlockScopedData, oneof: "message" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Response {
    return new Response().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Response {
    return new Response().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Response {
    return new Response().fromJsonString(jsonString, options);
  }

  static equals(a: Response | PlainMessage<Response> | undefined, b: Response | PlainMessage<Response> | undefined): boolean {
    return proto3.util.equals(Response, a, b);
  }
}

/**
 * @generated from message sf.substreams.v1.SessionInit
 */
export class SessionInit extends Message<SessionInit> {
  /**
   * @generated from field: string trace_id = 1;
   */
  traceId = "";

  constructor(data?: PartialMessage<SessionInit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.substreams.v1.SessionInit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trace_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SessionInit {
    return new SessionInit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SessionInit {
    return new SessionInit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SessionInit {
    return new SessionInit().fromJsonString(jsonString, options);
  }

  static equals(a: SessionInit | PlainMessage<SessionInit> | undefined, b: SessionInit | PlainMessage<SessionInit> | undefined): boolean {
    return proto3.util.equals(SessionInit, a, b);
  }
}

/**
 * @generated from message sf.substreams.v1.InitialSnapshotComplete
 */
export class InitialSnapshotComplete extends Message<InitialSnapshotComplete> {
  /**
   * @generated from field: string cursor = 1;
   */
  cursor = "";

  constructor(data?: PartialMessage<InitialSnapshotComplete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.substreams.v1.InitialSnapshotComplete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cursor", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InitialSnapshotComplete {
    return new InitialSnapshotComplete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InitialSnapshotComplete {
    return new InitialSnapshotComplete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InitialSnapshotComplete {
    return new InitialSnapshotComplete().fromJsonString(jsonString, options);
  }

  static equals(a: InitialSnapshotComplete | PlainMessage<InitialSnapshotComplete> | undefined, b: InitialSnapshotComplete | PlainMessage<InitialSnapshotComplete> | undefined): boolean {
    return proto3.util.equals(InitialSnapshotComplete, a, b);
  }
}

/**
 * @generated from message sf.substreams.v1.InitialSnapshotData
 */
export class InitialSnapshotData extends Message<InitialSnapshotData> {
  /**
   * @generated from field: string module_name = 1;
   */
  moduleName = "";

  /**
   * @generated from field: sf.substreams.v1.StoreDeltas deltas = 2;
   */
  deltas?: StoreDeltas;

  /**
   * @generated from field: uint64 sent_keys = 4;
   */
  sentKeys = protoInt64.zero;

  /**
   * @generated from field: uint64 total_keys = 3;
   */
  totalKeys = protoInt64.zero;

  constructor(data?: PartialMessage<InitialSnapshotData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.substreams.v1.InitialSnapshotData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "module_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "deltas", kind: "message", T: StoreDeltas },
    { no: 4, name: "sent_keys", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "total_keys", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InitialSnapshotData {
    return new InitialSnapshotData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InitialSnapshotData {
    return new InitialSnapshotData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InitialSnapshotData {
    return new InitialSnapshotData().fromJsonString(jsonString, options);
  }

  static equals(a: InitialSnapshotData | PlainMessage<InitialSnapshotData> | undefined, b: InitialSnapshotData | PlainMessage<InitialSnapshotData> | undefined): boolean {
    return proto3.util.equals(InitialSnapshotData, a, b);
  }
}

/**
 * @generated from message sf.substreams.v1.BlockScopedData
 */
export class BlockScopedData extends Message<BlockScopedData> {
  /**
   * @generated from field: repeated sf.substreams.v1.ModuleOutput outputs = 1;
   */
  outputs: ModuleOutput[] = [];

  /**
   * @generated from field: sf.substreams.v1.Clock clock = 3;
   */
  clock?: Clock;

  /**
   * @generated from field: sf.substreams.v1.ForkStep step = 6;
   */
  step = ForkStep.STEP_UNKNOWN;

  /**
   * @generated from field: string cursor = 10;
   */
  cursor = "";

  /**
   * Potentially non-deterministic. Reserved for future use.
   *
   * @generated from field: uint64 final_block_height = 11;
   */
  finalBlockHeight = protoInt64.zero;

  constructor(data?: PartialMessage<BlockScopedData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.substreams.v1.BlockScopedData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "outputs", kind: "message", T: ModuleOutput, repeated: true },
    { no: 3, name: "clock", kind: "message", T: Clock },
    { no: 6, name: "step", kind: "enum", T: proto3.getEnumType(ForkStep) },
    { no: 10, name: "cursor", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "final_block_height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlockScopedData {
    return new BlockScopedData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlockScopedData {
    return new BlockScopedData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlockScopedData {
    return new BlockScopedData().fromJsonString(jsonString, options);
  }

  static equals(a: BlockScopedData | PlainMessage<BlockScopedData> | undefined, b: BlockScopedData | PlainMessage<BlockScopedData> | undefined): boolean {
    return proto3.util.equals(BlockScopedData, a, b);
  }
}

/**
 * @generated from message sf.substreams.v1.ModuleOutput
 */
export class ModuleOutput extends Message<ModuleOutput> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from oneof sf.substreams.v1.ModuleOutput.data
   */
  data: {
    /**
     * @generated from field: google.protobuf.Any map_output = 2;
     */
    value: Any;
    case: "mapOutput";
  } | {
    /**
     * StoreDeltas are produced for store modules in development mode.
     * It is not possible to retrieve store models in production, with parallelization
     * enabled. If you need the deltas directly, write a pass through mapper module
     * that will get them down to you.
     *
     * @generated from field: sf.substreams.v1.StoreDeltas debug_store_deltas = 3;
     */
    value: StoreDeltas;
    case: "debugStoreDeltas";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: repeated string debug_logs = 4;
   */
  debugLogs: string[] = [];

  /**
   * LogsTruncated is a flag that tells you if you received all the logs or if they
   * were truncated because you logged too much (fixed limit currently is set to 128 KiB).
   *
   * @generated from field: bool debug_logs_truncated = 5;
   */
  debugLogsTruncated = false;

  /**
   * @generated from field: bool cached = 6;
   */
  cached = false;

  constructor(data?: PartialMessage<ModuleOutput>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.substreams.v1.ModuleOutput";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "map_output", kind: "message", T: Any, oneof: "data" },
    { no: 3, name: "debug_store_deltas", kind: "message", T: StoreDeltas, oneof: "data" },
    { no: 4, name: "debug_logs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "debug_logs_truncated", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "cached", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleOutput {
    return new ModuleOutput().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleOutput {
    return new ModuleOutput().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleOutput {
    return new ModuleOutput().fromJsonString(jsonString, options);
  }

  static equals(a: ModuleOutput | PlainMessage<ModuleOutput> | undefined, b: ModuleOutput | PlainMessage<ModuleOutput> | undefined): boolean {
    return proto3.util.equals(ModuleOutput, a, b);
  }
}

/**
 * @generated from message sf.substreams.v1.ModulesProgress
 */
export class ModulesProgress extends Message<ModulesProgress> {
  /**
   * @generated from field: repeated sf.substreams.v1.ModuleProgress modules = 1;
   */
  modules: ModuleProgress[] = [];

  constructor(data?: PartialMessage<ModulesProgress>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.substreams.v1.ModulesProgress";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "modules", kind: "message", T: ModuleProgress, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModulesProgress {
    return new ModulesProgress().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModulesProgress {
    return new ModulesProgress().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModulesProgress {
    return new ModulesProgress().fromJsonString(jsonString, options);
  }

  static equals(a: ModulesProgress | PlainMessage<ModulesProgress> | undefined, b: ModulesProgress | PlainMessage<ModulesProgress> | undefined): boolean {
    return proto3.util.equals(ModulesProgress, a, b);
  }
}

/**
 * @generated from message sf.substreams.v1.ModuleProgress
 */
export class ModuleProgress extends Message<ModuleProgress> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from oneof sf.substreams.v1.ModuleProgress.type
   */
  type: {
    /**
     * @generated from field: sf.substreams.v1.ModuleProgress.ProcessedRange processed_ranges = 2;
     */
    value: ModuleProgress_ProcessedRange;
    case: "processedRanges";
  } | {
    /**
     * @generated from field: sf.substreams.v1.ModuleProgress.InitialState initial_state = 3;
     */
    value: ModuleProgress_InitialState;
    case: "initialState";
  } | {
    /**
     * @generated from field: sf.substreams.v1.ModuleProgress.ProcessedBytes processed_bytes = 4;
     */
    value: ModuleProgress_ProcessedBytes;
    case: "processedBytes";
  } | {
    /**
     * @generated from field: sf.substreams.v1.ModuleProgress.Failed failed = 5;
     */
    value: ModuleProgress_Failed;
    case: "failed";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ModuleProgress>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.substreams.v1.ModuleProgress";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "processed_ranges", kind: "message", T: ModuleProgress_ProcessedRange, oneof: "type" },
    { no: 3, name: "initial_state", kind: "message", T: ModuleProgress_InitialState, oneof: "type" },
    { no: 4, name: "processed_bytes", kind: "message", T: ModuleProgress_ProcessedBytes, oneof: "type" },
    { no: 5, name: "failed", kind: "message", T: ModuleProgress_Failed, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleProgress {
    return new ModuleProgress().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleProgress {
    return new ModuleProgress().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleProgress {
    return new ModuleProgress().fromJsonString(jsonString, options);
  }

  static equals(a: ModuleProgress | PlainMessage<ModuleProgress> | undefined, b: ModuleProgress | PlainMessage<ModuleProgress> | undefined): boolean {
    return proto3.util.equals(ModuleProgress, a, b);
  }
}

/**
 * @generated from message sf.substreams.v1.ModuleProgress.ProcessedRange
 */
export class ModuleProgress_ProcessedRange extends Message<ModuleProgress_ProcessedRange> {
  /**
   * @generated from field: repeated sf.substreams.v1.BlockRange processed_ranges = 1;
   */
  processedRanges: BlockRange[] = [];

  constructor(data?: PartialMessage<ModuleProgress_ProcessedRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.substreams.v1.ModuleProgress.ProcessedRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "processed_ranges", kind: "message", T: BlockRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleProgress_ProcessedRange {
    return new ModuleProgress_ProcessedRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleProgress_ProcessedRange {
    return new ModuleProgress_ProcessedRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleProgress_ProcessedRange {
    return new ModuleProgress_ProcessedRange().fromJsonString(jsonString, options);
  }

  static equals(a: ModuleProgress_ProcessedRange | PlainMessage<ModuleProgress_ProcessedRange> | undefined, b: ModuleProgress_ProcessedRange | PlainMessage<ModuleProgress_ProcessedRange> | undefined): boolean {
    return proto3.util.equals(ModuleProgress_ProcessedRange, a, b);
  }
}

/**
 * @generated from message sf.substreams.v1.ModuleProgress.InitialState
 */
export class ModuleProgress_InitialState extends Message<ModuleProgress_InitialState> {
  /**
   * @generated from field: uint64 available_up_to_block = 2;
   */
  availableUpToBlock = protoInt64.zero;

  constructor(data?: PartialMessage<ModuleProgress_InitialState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.substreams.v1.ModuleProgress.InitialState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "available_up_to_block", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleProgress_InitialState {
    return new ModuleProgress_InitialState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleProgress_InitialState {
    return new ModuleProgress_InitialState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleProgress_InitialState {
    return new ModuleProgress_InitialState().fromJsonString(jsonString, options);
  }

  static equals(a: ModuleProgress_InitialState | PlainMessage<ModuleProgress_InitialState> | undefined, b: ModuleProgress_InitialState | PlainMessage<ModuleProgress_InitialState> | undefined): boolean {
    return proto3.util.equals(ModuleProgress_InitialState, a, b);
  }
}

/**
 * @generated from message sf.substreams.v1.ModuleProgress.ProcessedBytes
 */
export class ModuleProgress_ProcessedBytes extends Message<ModuleProgress_ProcessedBytes> {
  /**
   * @generated from field: uint64 total_bytes_read = 1;
   */
  totalBytesRead = protoInt64.zero;

  /**
   * @generated from field: uint64 total_bytes_written = 2;
   */
  totalBytesWritten = protoInt64.zero;

  /**
   * @generated from field: uint64 bytes_read_delta = 3;
   */
  bytesReadDelta = protoInt64.zero;

  /**
   * @generated from field: uint64 bytes_written_delta = 4;
   */
  bytesWrittenDelta = protoInt64.zero;

  /**
   * @generated from field: uint64 nano_seconds_delta = 5;
   */
  nanoSecondsDelta = protoInt64.zero;

  constructor(data?: PartialMessage<ModuleProgress_ProcessedBytes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.substreams.v1.ModuleProgress.ProcessedBytes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "total_bytes_read", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "total_bytes_written", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "bytes_read_delta", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "bytes_written_delta", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "nano_seconds_delta", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleProgress_ProcessedBytes {
    return new ModuleProgress_ProcessedBytes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleProgress_ProcessedBytes {
    return new ModuleProgress_ProcessedBytes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleProgress_ProcessedBytes {
    return new ModuleProgress_ProcessedBytes().fromJsonString(jsonString, options);
  }

  static equals(a: ModuleProgress_ProcessedBytes | PlainMessage<ModuleProgress_ProcessedBytes> | undefined, b: ModuleProgress_ProcessedBytes | PlainMessage<ModuleProgress_ProcessedBytes> | undefined): boolean {
    return proto3.util.equals(ModuleProgress_ProcessedBytes, a, b);
  }
}

/**
 * @generated from message sf.substreams.v1.ModuleProgress.Failed
 */
export class ModuleProgress_Failed extends Message<ModuleProgress_Failed> {
  /**
   * @generated from field: string reason = 1;
   */
  reason = "";

  /**
   * @generated from field: repeated string logs = 2;
   */
  logs: string[] = [];

  /**
   * FailureLogsTruncated is a flag that tells you if you received all the logs or if they
   * were truncated because you logged too much (fixed limit currently is set to 128 KiB).
   *
   * @generated from field: bool logs_truncated = 3;
   */
  logsTruncated = false;

  constructor(data?: PartialMessage<ModuleProgress_Failed>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.substreams.v1.ModuleProgress.Failed";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "logs", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "logs_truncated", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModuleProgress_Failed {
    return new ModuleProgress_Failed().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModuleProgress_Failed {
    return new ModuleProgress_Failed().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModuleProgress_Failed {
    return new ModuleProgress_Failed().fromJsonString(jsonString, options);
  }

  static equals(a: ModuleProgress_Failed | PlainMessage<ModuleProgress_Failed> | undefined, b: ModuleProgress_Failed | PlainMessage<ModuleProgress_Failed> | undefined): boolean {
    return proto3.util.equals(ModuleProgress_Failed, a, b);
  }
}

/**
 * @generated from message sf.substreams.v1.BlockRange
 */
export class BlockRange extends Message<BlockRange> {
  /**
   * @generated from field: uint64 start_block = 2;
   */
  startBlock = protoInt64.zero;

  /**
   * @generated from field: uint64 end_block = 3;
   */
  endBlock = protoInt64.zero;

  constructor(data?: PartialMessage<BlockRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.substreams.v1.BlockRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "start_block", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "end_block", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlockRange {
    return new BlockRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlockRange {
    return new BlockRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlockRange {
    return new BlockRange().fromJsonString(jsonString, options);
  }

  static equals(a: BlockRange | PlainMessage<BlockRange> | undefined, b: BlockRange | PlainMessage<BlockRange> | undefined): boolean {
    return proto3.util.equals(BlockRange, a, b);
  }
}

/**
 * @generated from message sf.substreams.v1.StoreDeltas
 */
export class StoreDeltas extends Message<StoreDeltas> {
  /**
   * @generated from field: repeated sf.substreams.v1.StoreDelta deltas = 1;
   */
  deltas: StoreDelta[] = [];

  constructor(data?: PartialMessage<StoreDeltas>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.substreams.v1.StoreDeltas";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "deltas", kind: "message", T: StoreDelta, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StoreDeltas {
    return new StoreDeltas().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StoreDeltas {
    return new StoreDeltas().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StoreDeltas {
    return new StoreDeltas().fromJsonString(jsonString, options);
  }

  static equals(a: StoreDeltas | PlainMessage<StoreDeltas> | undefined, b: StoreDeltas | PlainMessage<StoreDeltas> | undefined): boolean {
    return proto3.util.equals(StoreDeltas, a, b);
  }
}

/**
 * @generated from message sf.substreams.v1.StoreDelta
 */
export class StoreDelta extends Message<StoreDelta> {
  /**
   * @generated from field: sf.substreams.v1.StoreDelta.Operation operation = 1;
   */
  operation = StoreDelta_Operation.UNSET;

  /**
   * @generated from field: uint64 ordinal = 2;
   */
  ordinal = protoInt64.zero;

  /**
   * @generated from field: string key = 3;
   */
  key = "";

  /**
   * @generated from field: bytes old_value = 4;
   */
  oldValue = new Uint8Array(0);

  /**
   * @generated from field: bytes new_value = 5;
   */
  newValue = new Uint8Array(0);

  constructor(data?: PartialMessage<StoreDelta>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.substreams.v1.StoreDelta";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operation", kind: "enum", T: proto3.getEnumType(StoreDelta_Operation) },
    { no: 2, name: "ordinal", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "old_value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "new_value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StoreDelta {
    return new StoreDelta().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StoreDelta {
    return new StoreDelta().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StoreDelta {
    return new StoreDelta().fromJsonString(jsonString, options);
  }

  static equals(a: StoreDelta | PlainMessage<StoreDelta> | undefined, b: StoreDelta | PlainMessage<StoreDelta> | undefined): boolean {
    return proto3.util.equals(StoreDelta, a, b);
  }
}

/**
 * @generated from enum sf.substreams.v1.StoreDelta.Operation
 */
export enum StoreDelta_Operation {
  /**
   * @generated from enum value: UNSET = 0;
   */
  UNSET = 0,

  /**
   * @generated from enum value: CREATE = 1;
   */
  CREATE = 1,

  /**
   * @generated from enum value: UPDATE = 2;
   */
  UPDATE = 2,

  /**
   * @generated from enum value: DELETE = 3;
   */
  DELETE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(StoreDelta_Operation)
proto3.util.setEnumType(StoreDelta_Operation, "sf.substreams.v1.StoreDelta.Operation", [
  { no: 0, name: "UNSET" },
  { no: 1, name: "CREATE" },
  { no: 2, name: "UPDATE" },
  { no: 3, name: "DELETE" },
]);

/**
 * @generated from message sf.substreams.v1.Output
 */
export class Output extends Message<Output> {
  /**
   * @generated from field: uint64 block_num = 1;
   */
  blockNum = protoInt64.zero;

  /**
   * @generated from field: string block_id = 2;
   */
  blockId = "";

  /**
   * @generated from field: google.protobuf.Timestamp timestamp = 4;
   */
  timestamp?: Timestamp;

  /**
   * @generated from field: google.protobuf.Any value = 10;
   */
  value?: Any;

  constructor(data?: PartialMessage<Output>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sf.substreams.v1.Output";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "block_num", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "block_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "timestamp", kind: "message", T: Timestamp },
    { no: 10, name: "value", kind: "message", T: Any },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Output {
    return new Output().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Output {
    return new Output().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Output {
    return new Output().fromJsonString(jsonString, options);
  }

  static equals(a: Output | PlainMessage<Output> | undefined, b: Output | PlainMessage<Output> | undefined): boolean {
    return proto3.util.equals(Output, a, b);
  }
}

